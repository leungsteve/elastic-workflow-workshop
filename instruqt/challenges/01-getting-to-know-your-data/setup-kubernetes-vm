#!/bin/bash
#
# Setup script for Challenge 1 â€” runs on kubernetes-vm
#
# Responsibilities:
#   1. Bootstrap ECK + Elasticsearch via the shared workshop script
#   2. Wait for the ES cluster to be healthy
#   3. Register a GCS snapshot repository and restore the pre-built snapshot
#   4. Wait for Kibana and enable the Workflows UI
#

set -e

# ==============================================================================
# Step 1: Bootstrap ECK / Elasticsearch / Kibana
# ==============================================================================
echo "=============================================="
echo "[kubernetes-vm] Challenge 1 Setup"
echo "=============================================="
echo ""
echo "[1/7] Running workshop bootstrap script..."
/opt/workshops/elastic-llm.sh

# ==============================================================================
# Step 2: Retrieve ES credentials from k8s secret
# ==============================================================================
echo ""
echo "[2/7] Retrieving Elasticsearch credentials..."
ES_PASS=$(kubectl get secret elasticsearch-es-elastic-user -n default \
    -o jsonpath='{.data.elastic}' | base64 -d)
echo "  Credentials retrieved."

# Discover ES service ClusterIP (ES runs in a pod, not on localhost)
ES_SVC_IP=$(kubectl get svc elasticsearch-es-http -n default \
    -o jsonpath='{.spec.clusterIP}')
ES_URL="http://${ES_SVC_IP}:9200"
echo "  Elasticsearch service: ${ES_URL}"

CURL_ES="curl -s -k -u elastic:${ES_PASS}"

# ==============================================================================
# Step 3: Wait for Elasticsearch cluster health (green or yellow)
# ==============================================================================
echo ""
echo "[3/7] Waiting for Elasticsearch cluster health..."
MAX_RETRIES=60
RETRY=0

until ${CURL_ES} "${ES_URL}/_cluster/health" 2>/dev/null \
      | grep -q '"status":"green"\|"status":"yellow"'; do
    RETRY=$((RETRY + 1))
    if [ $RETRY -ge $MAX_RETRIES ]; then
        echo "  ERROR: Elasticsearch did not become ready after ${MAX_RETRIES} attempts"
        exit 1
    fi
    if [ $((RETRY % 5)) -eq 0 ]; then
        echo "  Debug: $(${CURL_ES} "${ES_URL}/_cluster/health" 2>&1 | head -c 200)"
    fi
    echo "  Waiting... (attempt ${RETRY}/${MAX_RETRIES})"
    sleep 5
done
echo "  Elasticsearch is healthy!"

# ==============================================================================
# Step 4: Register GCS snapshot repository
# ==============================================================================
echo ""
echo "[4/7] Registering GCS snapshot repository..."

${CURL_ES} -X PUT "${ES_URL}/_snapshot/workshop-snapshot?verify=false" \
    -H 'Content-Type: application/json' \
    -d '{
  "type": "gcs",
  "settings": {
    "bucket": "instruqt-workshop-snapshot-public",
    "base_path": "elastic-whats-new-9.3.0/data/snapshot-v2",
    "client": "sa",
    "readonly": true
  }
}'
echo ""
echo "  Snapshot repository registered."

# ==============================================================================
# Step 5: Restore snapshot (wait for completion)
# ==============================================================================
echo ""
echo "[5/7] Restoring snapshot (this may take a minute)..."

RESTORE_RESPONSE=$(${CURL_ES} -X POST \
    "${ES_URL}/_snapshot/workshop-snapshot/snapshot-v1/_restore?wait_for_completion=true" \
    -H 'Content-Type: application/json' \
    -d '{
  "indices": "*",
  "include_global_state": false
}')

echo "  Restore response: ${RESTORE_RESPONSE}"

# ==============================================================================
# Step 6: Create default ingest pipeline for timestamps
# ==============================================================================
echo ""
echo "[6/8] Setting up ingest pipeline for detected_at timestamps..."

${CURL_ES} -X PUT "${ES_URL}/_ingest/pipeline/set_timestamp" \
    -H 'Content-Type: application/json' \
    -d '{
  "description": "Sets detected_at to the current time on ingest",
  "processors": [
    {
      "set": {
        "field": "detected_at",
        "value": "{{{_ingest.timestamp}}}",
        "override": false
      }
    }
  ]
}'
echo ""

# Set as default pipeline on incidents and notifications
for idx in incidents notifications; do
    ${CURL_ES} -X PUT "${ES_URL}/${idx}/_settings" \
        -H 'Content-Type: application/json' \
        -d '{"index.default_pipeline": "set_timestamp"}'
done
echo "  Ingest pipeline configured."

# ==============================================================================
# Step 7: Verify doc counts
# ==============================================================================
echo ""
echo "[7/8] Verifying restored indices..."

get_doc_count() {
    local index="$1"
    ${CURL_ES} "${ES_URL}/${index}/_count" 2>/dev/null \
        | grep -o '"count":[0-9]*' | grep -o '[0-9]*' || echo "0"
}

for index in businesses users reviews; do
    count=$(get_doc_count "$index")
    echo "  ${index}: ${count} documents"
done

# ==============================================================================
# Step 8: Wait for Kibana
# ==============================================================================
echo ""
echo "[8/8] Waiting for Kibana..."

# Discover Kibana service ClusterIP
KB_SVC_IP=$(kubectl get svc kibana-kb-http -n default \
    -o jsonpath='{.spec.clusterIP}')
KIBANA_URL="http://${KB_SVC_IP}:5601"
echo "  Kibana service: ${KIBANA_URL}"

CURL_KB="curl -s -u elastic:${ES_PASS}"
MAX_RETRIES=60
RETRY=0

until ${CURL_KB} "${KIBANA_URL}/api/status" 2>/dev/null \
      | grep -q '"level":"available"'; do
    RETRY=$((RETRY + 1))
    if [ $RETRY -ge $MAX_RETRIES ]; then
        echo "  Warning: Kibana did not become ready in time."
        break
    fi
    echo "  Waiting for Kibana... (attempt ${RETRY}/${MAX_RETRIES})"
    sleep 5
done
echo "  Kibana is ready!"

# NOTE: Workflows UI must be enabled manually by attendees via Kibana Dev Tools:
#   POST kbn:/internal/kibana/settings
#   {"changes": {"workflows:ui:enabled": true}}
# The settings API is not available in this Kibana configuration (9.4.0).

# ==============================================================================
# Done
# ==============================================================================
echo ""
echo "=============================================="
echo "[kubernetes-vm] Challenge 1 setup complete!"
echo "=============================================="
